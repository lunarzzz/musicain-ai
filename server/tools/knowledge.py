"""é—®ç­”æŒ‡å— & å®¢æœæœåŠ¡ â€” RAG çŸ¥è¯†æ£€ç´¢ã€ä¸Šä¼ é¢„æ£€

MVP ä½¿ç”¨ FAISS å†…å­˜å‘é‡åº“ + Markdown çŸ¥è¯†æ–‡æ¡£ã€‚
"""

from __future__ import annotations

import os
from pathlib import Path
import httpx

from langchain_core.tools import tool
from config import settings

# â”€â”€ çŸ¥è¯†åº“æ•°æ® (å†…è” Mockï¼Œæ›¿ä»£ FAISS å‘é‡æ£€ç´¢) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_KNOWLEDGE_BASE: dict[str, list[dict]] = {
    "å…¥é©»": [
        {
            "q": "å¦‚ä½•æˆä¸ºè…¾è®¯éŸ³ä¹äººï¼Ÿ",
            "a": "1. è®¿é—®éŸ³ä¹äººå¼€æ”¾å¹³å°å®˜ç½‘æˆ–å°ç¨‹åº\n"
                 "2. é€‰æ‹©èº«ä»½ç±»å‹ï¼ˆåŸåˆ›éŸ³ä¹äºº / ç¿»å”±æ­Œæ‰‹ / åˆ¶ä½œäºº / å‚ç‰Œï¼‰\n"
                 "3. å¡«å†™åŸºæœ¬ä¿¡æ¯å¹¶ä¸Šä¼ èº«ä»½è¯æ˜\n"
                 "4. æäº¤è‡³å°‘ 1 é¦–åŸåˆ›ä½œå“\n"
                 "5. ç­‰å¾…å®¡æ ¸ï¼ˆé€šå¸¸ 3-5 ä¸ªå·¥ä½œæ—¥ï¼‰",
            "source": "å…¥é©»æŒ‡å—",
        },
        {
            "q": "å…¥é©»éœ€è¦ä»€ä¹ˆæ¡ä»¶ï¼Ÿ",
            "a": "ä¸ªäººå…¥é©»éœ€è¦ï¼š\n"
                 "- å¹´æ»¡ 18 å²ï¼ˆæœªæ»¡ 18 éœ€ç›‘æŠ¤äººç­¾å­—ï¼‰\n"
                 "- æœ‰æ•ˆèº«ä»½è¯ä»¶\n"
                 "- è‡³å°‘ 1 é¦–å®Œæ•´åŸåˆ›éŸ³ä¹ä½œå“\n"
                 "- ä½œå“ä¸å«ä¾µæƒå†…å®¹\n\n"
                 "æœºæ„å…¥é©»é¢å¤–éœ€è¦ï¼š\n"
                 "- è¥ä¸šæ‰§ç…§\n"
                 "- æ³•äººæˆæƒä¹¦\n"
                 "- éŸ³ä¹ç‰ˆæƒè¯æ˜ææ–™",
            "source": "å…¥é©»æŒ‡å—",
        },
    ],
    "ä¸Šä¼ ": [
        {
            "q": "ä¸Šä¼ æ­Œæ›²éœ€è¦ä»€ä¹ˆæ ¼å¼ï¼Ÿ",
            "a": "éŸ³é¢‘æ ¼å¼è¦æ±‚ï¼š\n"
                 "- æ ¼å¼ï¼šWAV / FLAC / MP3ï¼ˆæ¨è WAV æˆ– FLACï¼‰\n"
                 "- é‡‡æ ·ç‡ï¼šâ‰¥ 44.1kHz\n"
                 "- ä½æ·±ï¼šâ‰¥ 16bit\n"
                 "- ç ç‡ï¼šMP3 â‰¥ 320kbps\n\n"
                 "å°é¢è¦æ±‚ï¼š\n"
                 "- å°ºå¯¸ï¼šâ‰¥ 3000Ã—3000 px\n"
                 "- æ ¼å¼ï¼šJPG / PNG\n"
                 "- å¤§å°ï¼šâ‰¤ 10MB\n"
                 "- ä¸å«äºŒç»´ç ã€æ°´å°ã€è”ç³»æ–¹å¼",
            "source": "ä¸Šä¼ è§„èŒƒ",
        },
        {
            "q": "æ­Œè¯æ ¼å¼è¦æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ",
            "a": "æ­Œè¯æ ¼å¼è¦æ±‚ï¼š\n"
                 "- æ”¯æŒ LRC å’Œçº¯æ–‡æœ¬æ ¼å¼\n"
                 "- LRC éœ€è¦æ—¶é—´æ ‡ç­¾ç²¾ç¡®åˆ°æ¯«ç§’\n"
                 "- çº¯æ–‡æœ¬éœ€è¦æŒ‰æ®µè½åˆ†è¡Œ\n"
                 "- ä¸å«å…¶ä»–å¹³å°çš„æ°´å°æˆ–æ ‡è¯†\n"
                 "- åŒ…å«ç¿»è¯‘æ­Œè¯æ—¶éœ€æ ‡æ³¨è¯­ç§",
            "source": "ä¸Šä¼ è§„èŒƒ",
        },
    ],
    "å®¡æ ¸": [
        {
            "q": "å®¡æ ¸ä¸€èˆ¬éœ€è¦å¤šä¹…ï¼Ÿ",
            "a": "å®¡æ ¸æ—¶æ•ˆï¼š\n"
                 "- å¸¸è§„å®¡æ ¸ï¼š1-3 ä¸ªå·¥ä½œæ—¥\n"
                 "- èŠ‚å‡æ—¥æœŸé—´å¯èƒ½å»¶é•¿è‡³ 5 ä¸ªå·¥ä½œæ—¥\n"
                 "- ç´§æ€¥å‘è¡Œå¯ç”³è¯·åŠ æ€¥å®¡æ ¸ï¼ˆéœ€æå‰æŠ¥å¤‡ï¼‰\n\n"
                 "å¸¸è§é©³å›åŸå› ï¼š\n"
                 "1. å°é¢ä¸åˆè§„ï¼ˆå«äºŒç»´ç /æ°´å°/ä¾µæƒå›¾ç‰‡ï¼‰\n"
                 "2. éŸ³é¢‘è´¨é‡ä¸è¾¾æ ‡ï¼ˆåº•å™ªè¿‡å¤§/å‰Šæ³¢å¤±çœŸï¼‰\n"
                 "3. å…ƒæ•°æ®ä¸å®Œæ•´ï¼ˆç¼ºå°‘ä½œè€…/ä½œæ›²/ç¼–æ›²ä¿¡æ¯ï¼‰\n"
                 "4. ç–‘ä¼¼ä¾µæƒï¼ˆæ›²è°ƒ/æ­Œè¯ä¸å·²æœ‰ä½œå“é«˜åº¦ç›¸ä¼¼ï¼‰",
            "source": "å®¡æ ¸è§„åˆ™",
        },
    ],
    "ç»“ç®—": [
        {
            "q": "ç»“ç®—è§„åˆ™æ˜¯æ€æ ·çš„ï¼Ÿ",
            "a": "ç»“ç®—å‘¨æœŸä¸è§„åˆ™ï¼š\n"
                 "- ç»“ç®—å‘¨æœŸï¼šæœˆåº¦ç»“ç®—ï¼Œæ¬¡æœˆ 15 æ—¥ç”Ÿæˆè´¦å•\n"
                 "- æç°é—¨æ§›ï¼šæ»¡ 100 å…ƒå¯æç°\n"
                 "- åˆ°è´¦æ—¶é—´ï¼šæç°å 3-5 ä¸ªå·¥ä½œæ—¥\n"
                 "- åˆ†æˆæ¯”ä¾‹ï¼šæ ¹æ®åˆçº¦ç±»å‹ä¸åŒï¼Œä¸€èˆ¬ä¸º 50%-70%\n\n"
                 "ç»“ç®—æ”¶å…¥æ¥æºï¼š\n"
                 "1. æ’­æ”¾åˆ†æˆï¼ˆæŒ‰æœ‰æ•ˆæ’­æ”¾é‡ï¼‰\n"
                 "2. ä¼šå‘˜ä¸“äº«åˆ†æˆï¼ˆVIP ç”¨æˆ·æ’­æ”¾åŠ æƒï¼‰\n"
                 "3. æ•°å­—ä¸“è¾‘/å•æ›²é”€å”®åˆ†æˆ\n"
                 "4. å½©é“ƒ/BGM æˆæƒæ”¶ç›Š",
            "source": "ç»“ç®—è¯´æ˜",
        },
        {
            "q": "ä¸ºä»€ä¹ˆæˆ‘çš„æ”¶å…¥å˜å°‘äº†ï¼Ÿ",
            "a": "æ”¶å…¥å˜åŒ–å¸¸è§åŸå› ï¼š\n"
                 "1. **ç»“ç®—æ­Œæ›²æ•°å˜åŒ–**ï¼šéƒ¨åˆ†æ­Œæ›²æˆæƒåˆ°æœŸæˆ–ä¸‹æ¶\n"
                 "2. **æ’­æ”¾é‡æ³¢åŠ¨**ï¼šè‡ªç„¶è¡°å‡æˆ–æ¨èä½è°ƒæ•´\n"
                 "3. **å¹³å°å•ä»·è°ƒæ•´**ï¼šå­£åº¦æ€§ CPM æµ®åŠ¨\n"
                 "4. **æ–°æ­Œç»“ç®—å»¶è¿Ÿ**ï¼šå½“æœˆå‘å¸ƒçš„æ­Œé€šå¸¸ä¸‹æœˆæ‰å¼€å§‹ç»“ç®—\n"
                 "5. **æ‰£ç¨/æ‰‹ç»­è´¹**ï¼šä¸ªç¨ä»£æ‰£æ¯”ä¾‹å˜åŒ–\n\n"
                 "å¦‚æœ‰å¼‚å¸¸ï¼Œå¯é€šè¿‡ AI åŠ©æ‰‹ä½¿ç”¨ã€Œç»“ç®—å˜åŒ–åˆ†æã€åŠŸèƒ½æŸ¥çœ‹è¯¦ç»†å½’å› ã€‚",
            "source": "ç»“ç®— FAQ",
        },
    ],
    "ç‰ˆæƒ": [
        {
            "q": "å¦‚ä½•ä¿æŠ¤æˆ‘çš„æ­Œæ›²ç‰ˆæƒï¼Ÿ",
            "a": "ç‰ˆæƒä¿æŠ¤å»ºè®®ï¼š\n"
                 "1. **åˆ›ä½œç•™ç—•**ï¼šä¿å­˜åˆ›ä½œè¿‡ç¨‹è®°å½•ï¼ˆdemoã€æ‰‹ç¨¿ã€æ—¶é—´æˆ³ï¼‰\n"
                 "2. **ç‰ˆæƒç™»è®°**ï¼šé€šè¿‡ä¸­å›½ç‰ˆæƒä¿æŠ¤ä¸­å¿ƒæˆ–çœçº§ç‰ˆæƒå±€ç™»è®°\n"
                 "3. **å¹³å°ç»´æƒ**ï¼šå‘ç°ä¾µæƒå¯åœ¨å¹³å°ã€Œç»´æƒä¸­å¿ƒã€æäº¤æŠ•è¯‰\n"
                 "4. **è¯æ®ä¿å…¨**ï¼šä½¿ç”¨å¯ä¿¡æ—¶é—´æˆ³æˆ–åŒºå—é“¾å­˜è¯\n\n"
                 "å¹³å°ä¾§ä¿æŠ¤æªæ–½ï¼š\n"
                 "- éŸ³é¢‘æŒ‡çº¹æ£€æµ‹ï¼ˆä¸Šä¼ æ—¶è‡ªåŠ¨æ¯”å¯¹ï¼‰\n"
                 "- ä¾µæƒä¸¾æŠ¥é€šé“ï¼ˆ7Ã—24 å°æ—¶å—ç†ï¼‰\n"
                 "- ç»´æƒç»“æœè·Ÿè¸ªï¼ˆå¤„ç†æ—¶æ•ˆ â‰¤ 15 ä¸ªå·¥ä½œæ—¥ï¼‰",
            "source": "ç‰ˆæƒä¿æŠ¤æŒ‡å—",
        },
    ],
    "æ´»åŠ¨": [
        {
            "q": "æœ€è¿‘æœ‰ä»€ä¹ˆéŸ³ä¹äººæ´»åŠ¨ï¼Ÿ",
            "a": "å½“å‰è¿›è¡Œä¸­çš„æ´»åŠ¨ï¼š\n\n"
                 "ğŸµ **æ˜¥æ—¥åˆ›ä½œå¤§èµ›**\n"
                 "- æ—¶é—´ï¼š2026-02-15 ~ 2026-03-31\n"
                 "- ä¸»é¢˜ï¼šä»¥ã€Œæ˜¥å¤©ã€ä¸ºçµæ„Ÿåˆ›ä½œåŸåˆ›æ­Œæ›²\n"
                 "- å¥–åŠ±ï¼šä¸€ç­‰å¥– Â¥10,000 + é¦–é¡µæ¨èä½ 7 å¤©\n\n"
                 "ğŸ¤ **æ–°äººæ‰¶æŒè®¡åˆ’ S3**\n"
                 "- æ—¶é—´ï¼šå¸¸å¹´æœ‰æ•ˆ\n"
                 "- å¯¹è±¡ï¼šå…¥é©» â‰¤ 6 ä¸ªæœˆçš„æ–°éŸ³ä¹äºº\n"
                 "- æƒç›Šï¼šå…è´¹æ¨èä½ + 1v1 è¿è¥æŒ‡å¯¼\n\n"
                 "ğŸ“¢ **çŸ­è§†é¢‘å®£æ¨è¡¥è´´**\n"
                 "- æ—¶é—´ï¼š2026-02-01 ~ 2026-04-30\n"
                 "- å†…å®¹ï¼šä½¿ç”¨å¹³å°æ­Œæ›²åˆ¶ä½œçŸ­è§†é¢‘ï¼Œæ’­æ”¾é‡ â‰¥ 10,000 å¯è·è¡¥è´´",
            "source": "æ´»åŠ¨ä¸­å¿ƒ",
        },
    ],
}


@tool
def search_knowledge(query: str, category: str = "all") -> dict:
    """åœ¨çŸ¥è¯†åº“ä¸­æœç´¢éŸ³ä¹äººç›¸å…³è§„åˆ™å’ŒæŒ‡å—ã€‚æ¶µç›–å…¥é©»ã€ä¸Šä¼ ã€å®¡æ ¸ã€ç»“ç®—ã€ç‰ˆæƒã€æ´»åŠ¨ç­‰å¸¸è§é—®é¢˜ã€‚

    å‚æ•°:
        query: ç”¨æˆ·çš„é—®é¢˜
        category: åˆ†ç±»ç­›é€‰ï¼Œå¯é€‰ 'å…¥é©»' / 'ä¸Šä¼ ' / 'å®¡æ ¸' / 'ç»“ç®—' / 'ç‰ˆæƒ' / 'æ´»åŠ¨' / 'all'
    """
    results = []

    if category != "all" and category in _KNOWLEDGE_BASE:
        search_items = [(category, items) for items in [_KNOWLEDGE_BASE[category]]]
    else:
        search_items = list(_KNOWLEDGE_BASE.items())

    query_lower = query.lower()

    for cat, items in search_items:
        for item in items:
            # ç®€å•å…³é”®è¯åŒ¹é… (MVP é˜¶æ®µï¼Œåç»­æ›¿æ¢ä¸ºå‘é‡æ£€ç´¢)
            q_text = item["q"].lower()
            a_text = item["a"].lower()
            if any(kw in q_text or kw in a_text for kw in _extract_keywords(query_lower)):
                results.append({
                    "category": cat,
                    "question": item["q"],
                    "answer": item["a"],
                    "source": item["source"],
                    "relevance": "high",
                })

    # å¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ï¼Œè¿”å›æœ€ç›¸å…³çš„åˆ†ç±»
    if not results:
        best_cat = _guess_category(query_lower)
        if best_cat and best_cat in _KNOWLEDGE_BASE:
            for item in _KNOWLEDGE_BASE[best_cat][:2]:
                results.append({
                    "category": best_cat,
                    "question": item["q"],
                    "answer": item["a"],
                    "source": item["source"],
                    "relevance": "medium",
                })

    return {
        "query": query,
        "results": results[:3],
        "total_found": len(results),
        "note": "ä»¥ä¸Šä¿¡æ¯æ¥è‡ªå¹³å°è§„åˆ™æ–‡æ¡£ï¼Œå¦‚éœ€äººå·¥å®¢æœè¯·ç‚¹å‡»ã€Œè”ç³»å®¢æœã€",
    }


@tool
def check_upload_compliance(
    audio_format: str = "mp3",
    sample_rate: int = 44100,
    cover_size: str = "3000x3000",
    has_lyrics: bool = True,
    has_composer_info: bool = True,
) -> dict:
    """ä¸Šä¼ å‰é¢„æ£€ï¼Œæ£€æŸ¥éŸ³é¢‘å’Œå…ƒæ•°æ®æ˜¯å¦ç¬¦åˆå¹³å°è¦æ±‚ã€‚

    å‚æ•°:
        audio_format: éŸ³é¢‘æ ¼å¼ï¼Œå¦‚ 'wav' / 'flac' / 'mp3'
        sample_rate: é‡‡æ ·ç‡ (Hz)
        cover_size: å°é¢å°ºå¯¸ï¼Œå¦‚ '3000x3000'
        has_lyrics: æ˜¯å¦åŒ…å«æ­Œè¯
        has_composer_info: æ˜¯å¦åŒ…å«ä½œæ›²/ä½œè¯ä¿¡æ¯
    """
    issues = []
    warnings = []
    passed = []

    # æ£€æŸ¥éŸ³é¢‘æ ¼å¼
    if audio_format.lower() in ("wav", "flac"):
        passed.append(f"âœ… éŸ³é¢‘æ ¼å¼ {audio_format.upper()} â€” ç¬¦åˆè¦æ±‚ï¼ˆæ¨èæ ¼å¼ï¼‰")
    elif audio_format.lower() == "mp3":
        warnings.append("âš ï¸ éŸ³é¢‘æ ¼å¼ MP3 â€” å¯æ¥å—ï¼Œä½†å»ºè®®ä½¿ç”¨ WAV æˆ– FLAC ä»¥è·å¾—æ›´å¥½éŸ³è´¨")
    else:
        issues.append(f"âŒ éŸ³é¢‘æ ¼å¼ {audio_format} â€” ä¸æ”¯æŒï¼Œè¯·è½¬æ¢ä¸º WAV / FLAC / MP3")

    # æ£€æŸ¥é‡‡æ ·ç‡
    if sample_rate >= 44100:
        passed.append(f"âœ… é‡‡æ ·ç‡ {sample_rate}Hz â€” ç¬¦åˆè¦æ±‚")
    else:
        issues.append(f"âŒ é‡‡æ ·ç‡ {sample_rate}Hz â€” ä¸è¶³ï¼Œè¦æ±‚ â‰¥ 44100Hz")

    # æ£€æŸ¥å°é¢
    try:
        w, h = map(int, cover_size.split("x"))
        if w >= 3000 and h >= 3000:
            passed.append(f"âœ… å°é¢å°ºå¯¸ {cover_size} â€” ç¬¦åˆè¦æ±‚")
        else:
            issues.append(f"âŒ å°é¢å°ºå¯¸ {cover_size} â€” è¿‡å°ï¼Œè¦æ±‚ â‰¥ 3000Ã—3000 px")
    except (ValueError, AttributeError):
        warnings.append("âš ï¸ å°é¢å°ºå¯¸æ ¼å¼æ— æ³•è§£æï¼Œè¯·ç¡®è®¤ â‰¥ 3000Ã—3000 px")

    # æ£€æŸ¥æ­Œè¯
    if has_lyrics:
        passed.append("âœ… æ­Œè¯ â€” å·²æä¾›")
    else:
        warnings.append("âš ï¸ ç¼ºå°‘æ­Œè¯ â€” éå¿…å¡«ä½†å¼ºçƒˆå»ºè®®æä¾›ï¼ˆå½±å“æœç´¢å’Œæ¨èï¼‰")

    # æ£€æŸ¥ä½œæ›²ä¿¡æ¯
    if has_composer_info:
        passed.append("âœ… ä½œæ›²/ä½œè¯ä¿¡æ¯ â€” å·²æä¾›")
    else:
        issues.append("âŒ ç¼ºå°‘ä½œæ›²/ä½œè¯ä¿¡æ¯ â€” å¿…å¡«é¡¹ï¼Œå¦åˆ™å°†è¢«é©³å›")

    can_upload = len(issues) == 0

    return {
        "can_upload": can_upload,
        "summary": "âœ… å¯ä»¥ä¸Šä¼ " if can_upload else f"âŒ å­˜åœ¨ {len(issues)} ä¸ªé—®é¢˜éœ€è¦ä¿®å¤",
        "issues": issues,
        "warnings": warnings,
        "passed": passed,
        "tip": "ä¿®å¤æ‰€æœ‰ âŒ é¡¹åå³å¯ä¸Šä¼ " if not can_upload else "æ‰€æœ‰å¿…éœ€é¡¹å‡å·²é€šè¿‡ï¼Œå¯ä»¥å¼€å§‹ä¸Šä¼ ",
    }


def _extract_keywords(text: str) -> list[str]:
    """ç®€å•å…³é”®è¯æå–"""
    keywords = []
    kw_map = {
        "å…¥é©»": ["å…¥é©»", "æ³¨å†Œ", "ç”³è¯·", "å¼€é€š", "æˆä¸º", "åŠ å…¥"],
        "ä¸Šä¼ ": ["ä¸Šä¼ ", "æ ¼å¼", "éŸ³é¢‘", "å°é¢", "æ­Œè¯", "æäº¤"],
        "å®¡æ ¸": ["å®¡æ ¸", "é©³å›", "é€šè¿‡", "å¤šä¹…", "æ—¶é—´"],
        "ç»“ç®—": ["ç»“ç®—", "æ”¶å…¥", "æç°", "åˆ†æˆ", "è´¦å•", "é’±", "æ”¶ç›Š"],
        "ç‰ˆæƒ": ["ç‰ˆæƒ", "ä¾µæƒ", "ç»´æƒ", "ä¿æŠ¤", "æŠ„è¢­"],
        "æ´»åŠ¨": ["æ´»åŠ¨", "æ¯”èµ›", "æ‰¶æŒ", "è¡¥è´´", "å¥–åŠ±"],
    }
    for cat, kws in kw_map.items():
        for kw in kws:
            if kw in text:
                keywords.append(kw)
    return keywords or [text[:4]]  # å›é€€åˆ°å–å‰4ä¸ªå­—


def _guess_category(text: str) -> str | None:
    """çŒœæµ‹é—®é¢˜æ‰€å±åˆ†ç±»"""
    cat_keywords = {
        "å…¥é©»": ["å…¥é©»", "æ³¨å†Œ", "åŠ å…¥", "å¼€é€š", "æ¡ä»¶"],
        "ä¸Šä¼ ": ["ä¸Šä¼ ", "æ ¼å¼", "æ–‡ä»¶", "æäº¤", "å‘å¸ƒ"],
        "å®¡æ ¸": ["å®¡æ ¸", "é©³å›", "ç­‰", "å¤šä¹…"],
        "ç»“ç®—": ["ç»“ç®—", "é’±", "æ”¶å…¥", "æç°"],
        "ç‰ˆæƒ": ["ç‰ˆæƒ", "ä¾µæƒ", "ç»´æƒ"],
        "æ´»åŠ¨": ["æ´»åŠ¨", "æ¯”èµ›", "å¥–"],
    }
    for cat, kws in cat_keywords.items():
        if any(kw in text for kw in kws):
            return cat
    return "å…¥é©»"


@tool
async def ragflow_search(query: str, top_k: int = 5) -> dict:
    """ä½¿ç”¨ RAGFlow æ£€ç´¢å®˜æ–¹å®¢æœåŠæ“ä½œæŒ‡å—æ–‡æ¡£ã€‚
    å¦‚æœé…ç½®äº† RAGFLOW_API_KEYï¼Œå°†è°ƒç”¨çœŸå®çš„ RAGFlow æœåŠ¡ã€‚
    å¦åˆ™å°†å›é€€åˆ°æœ¬åœ°çš„ search_knowledge æœºåˆ¶ã€‚

    å‚æ•°:
        query: ç”¨æˆ·çš„é—®é¢˜
        top_k: è¿”å›çš„æœ€å¤§æ–‡æ¡£ç‰‡æ®µæ•°
    """
    if not settings.RAGFLOW_API_KEY:
        # å¦‚æœæ²¡æœ‰é…ç½® API Keyï¼Œå›é€€åˆ°æœ¬åœ°æ£€ç´¢
        fallback_result = search_knowledge.invoke({"query": query, "category": "all"})
        fallback_result["note"] = "âš ï¸ å½“å‰æœªé…ç½® RAGFlow API Keyï¼Œå·²å›é€€åˆ°æœ¬åœ°åŸºç¡€ FAQ æ£€ç´¢ã€‚"
        return fallback_result

    url = f"{settings.RAGFLOW_BASE_URL.rstrip('/')}/api/v1/retrieval"
    headers = {
        "Authorization": f"Bearer {settings.RAGFLOW_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "question": query,
        "dataset_ids": settings.RAGFLOW_KB_ID,
        "top_k": top_k
    }

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.post(url, headers=headers, json=payload, timeout=10.0)
            resp.raise_for_status()
            data = resp.json()
            
            if data.get("code") == 0:
                chunks = data.get("data", {}).get("chunks", [])
                results = []
                for chunk in chunks:
                    results.append({
                        "category": "RAGFlow",
                        "question": "åŒ¹é…åˆ°çš„ç›¸å…³æ–‡æ¡£ç‰‡æ®µ",
                        "answer": chunk.get("content", ""),
                        "source": chunk.get("document_name", "æœªçŸ¥æ¥æº"),
                        "relevance": "high",
                    })
                
                # è‹¥ RAG æ²¡æœåˆ°ï¼Œå¯ç”¨å…œåº•
                if not results:
                    return {
                        "query": query,
                        "results": [],
                        "total_found": 0,
                        "note": "RAGFlow çŸ¥è¯†åº“ä¸­æœªæ‰¾åˆ°ç›¸å…³å†…å®¹ï¼Œè¯·å°è¯•æ¢ä¸ªå…³é”®è¯æˆ–è”ç³»äººå·¥å®¢æœã€‚"
                    }

                return {
                    "query": query,
                    "results": results[:top_k],
                    "total_found": len(results),
                    "note": "ä»¥ä¸Šä¿¡æ¯æ¥è‡ªå®˜æ–¹æ–‡æ¡£åº“ï¼Œä»…ä¾›å‚è€ƒã€‚"
                }
            else:
                raise ValueError(f"RAGFlow API Error: {data.get('message', 'Unknown error')}")

    except Exception as e:
        return {
            "query": query,
            "results": [],
            "error": str(e),
            "note": "è°ƒç”¨ RAGFlow æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åå†è¯•æˆ–è”ç³»ç®¡ç†å‘˜ã€‚"
        }
